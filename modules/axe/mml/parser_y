%{ 
#define YACC
#include "modules/common.h"
#include "modules/nethelper.h" 
#include "modules/axe/mml/parser.h" 
#include "modules/axe/mml/sections/sections.h" 
#include "modules/protocols/sigtran.h" 
#undef YACC

void generic_string_parameters(int key_index, int enum_param, char *str_value);


extern void yyerror(char *s);
/* if #define YYDEBUG 1 is defined, yacc provides on execution yacc trace */
/* if int yydebug = 1; is defined, together with -v build flag, y.output file is generated by yacc */
int  yydebug = 1;

#define __mmlcnf__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(mmlcnf)
#define __mmlcnf__strpar__		GENERIC_CASE_PARAM4_SELECT						(mmlcnf, lip, lpn, trn, info)
#define __mmlcnf__cmdend__   	GENERIC_CASE_CMD_END_ALIGN_DATA_TO_3KEY_INDEX	(mmlcnf, lip, lpn, trn)

#define __ss7loc__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(ss7loc)
#define __ss7loc__strpar__ 		GENERIC_CASE_PARAM3_SELECT						(ss7loc, ownsp, sptype, info)
#define __ss7loc__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(ss7loc, ownsp)

#define __ss7con__cmdstart__  	GENERIC_CASE_CMD_START_RESET_PARAM				(ss7con)
#define __ss7con__strpar__ 		GENERIC_CASE_PARAM7_SELECT						(ss7con, ownsp, sp, net, si, ni, sls, info)
#define __ss7con__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_2KEY_INDEX	(ss7con, ownsp, sp)

#define __trnloc__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(trnloc)
#define __trnloc__strpar__ 		GENERIC_CASE_PARAM7_SELECT						(trnloc, epid, user, lip, lpn, mode, trn, info)
#define __trnloc__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(trnloc, epid)

#define __trncon__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(trncon)
#define __trncon__strpar__ 		GENERIC_CASE_PARAM5_SELECT						(trncon, epid, said, rip, rpn, info)
#define __trncon__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_2KEY_INDEX	(trncon, epid, said)

#define __m3acon__cmdstart__	GENERIC_CASE_CMD_START_RESET_PARAM				(m3acon)
#define __m3acon__strpar__ 		GENERIC_CASE_PARAM4_SELECT						(m3acon, trnid, dest, bmode, info)
#define __m3acon__cmdend__		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_2KEY_INDEX	(m3acon, trnid, dest)

#define __m3loop__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(m3loop)
#define __m3loop__strpar__  	GENERIC_CASE_PARAM10_SELECT						(m3loop, dest1, trnid1, ownsp1, dest2, trnid2, ownsp2, dir, cicinc1, cicinc2, info)
#define __m3loop__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_3KEY_INDEX	(m3loop, dest1, trnid1, ownsp1)

#define __sccpcf__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(sccpcf)
#define __sccpcf__strpar__  	GENERIC_CASE_PARAM3_SELECT						(sccpcf, sp, ssn, info)
#define __sccpcf__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_2KEY_INDEX	(sccpcf, sp, ssn)

#define __bsci__cmdstart__ 		GENERIC_CASE_CMD_START_RESET_PARAM				(bsci)
#define __bsci__strpar__  		GENERIC_CASE_PARAM4_SELECT						(bsci, bsc, ownsp, mscsp, info)
#define __bsci__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(bsci, bsc)

#define __btsi__cmdstart__ 		GENERIC_CASE_CMD_START_RESET_PARAM				(btsi)
#define __btsi__strpar__  		GENERIC_CASE_PARAM7_SELECT						(btsi, bsc, cell, cgi_mcc, cgi_mnc, cgi_lac, cgi_ci, info)
#define __btsi__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_2KEY_INDEX	(btsi, bsc, cell)

#define __mei__cmdstart__ 		GENERIC_CASE_CMD_START_RESET_PARAM				(mei)
#define __mei__strpar__  		GENERIC_CASE_PARAM6_SELECT						(mei, me, imsi, range, bsc, cell, info)
#define __mei__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(mei, me)

#define __phonei__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(phonei)
#define __phonei__strpar__  	GENERIC_CASE_PARAM6_SELECT						(phonei, phone, Anum, Bnum, Bdest, range, info)
#define __phonei__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(phonei, phone)

#define __call__cmdstart__ 		GENERIC_CASE_CMD_START_RESET_PARAM				(call)
#define __call__strpar__  		GENERIC_CASE_PARAM8_SELECT						(call, id, caller, called, type, cps, duration, cic, info)
#define __call__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(call, id)

#define __stats__cmdstart__ 	GENERIC_CASE_CMD_START_RESET_PARAM				(stats)
#define __stats__strpar__  		GENERIC_CASE_PARAM1_SELECT						(stats, info)
#define __stats__cmdend__ 		GENERIC_CASE_CMD_END_ALIGN_DATA_TO_1KEY_INDEX	(stats, info)


int generic_command(int startcmd0_endcmd1, int enum_cmd, char *str_value) {
	
	
	if (startcmd0_endcmd1 == 0) { 
		mml.active_cmd = enum_cmd;				
		mml.active_cmd_par_index=0;
		mml.active_cmd_par_action=0;
		mml.execution_based_on_cmd_id=false;
		mml.execution_based_on_cmd_id_value=PARSER_MML_PARAM_MAX_NUMBER_MASK;
		
		// when starting new cmd, __cmdstart__ resets new index nomather if there is already
		// given mml with same key, on startcmd0_endcmd1 = 1, key is checked and if this new
		// index is not used, this reset does not have purpose
		
		switch ((enum Emml_commands) mml.active_cmd) {
		__mmlcnf__cmdstart__;
		__stats__cmdstart__;
		
		__ss7loc__cmdstart__;
		__ss7con__cmdstart__;

		__trnloc__cmdstart__;
		__trncon__cmdstart__;

		__m3acon__cmdstart__;
		__m3loop__cmdstart__;
		
		__sccpcf__cmdstart__;
		
		__bsci__cmdstart__;
		__btsi__cmdstart__;
		__mei__cmdstart__;
		__phonei__cmdstart__;
		__call__cmdstart__;
		}
		
		ErrorTraceHandle(2, "MML %s < ", str_value); 
			
	} else {
	
		ErrorTraceHandle(2, "> \n"); 
			
		if (!mml.execution_based_on_cmd_id) {
			// if there already exists data with same key, copy parameter data to that index and
			// do not increment cmd counter so that in next mml iteration, latest inxed 
			// data are reseted and overriden 
			
			// after this aligning, mml.active_cmd_par_index should contain valid new or already existing index
			
			switch ((enum Emml_commands) mml.active_cmd) {
			__mmlcnf__cmdend__;
			__stats__cmdend__;
			
			__ss7loc__cmdend__;
			__ss7con__cmdend__;
	
			__trnloc__cmdend__;
			__trncon__cmdend__;
	
			__m3acon__cmdend__;
			__m3loop__cmdend__;
			
			__sccpcf__cmdend__;
			
			__bsci__cmdend__;
			__btsi__cmdend__;		
			__mei__cmdend__;
			__phonei__cmdend__;
			__call__cmdend__;
			}
			
			if (mml.active_cmd_par_index == 0xFFFF) {
				ErrorTraceHandle(1, "generic_command(): All %s locations occupied.\n", str_value);
				mml_send_string("All %s locations occupied, increase command memory.\n", str_value);
				return 0; 
			}
		} else {
			if (mml.execution_based_on_cmd_id_value < PARSER_MML_PARAM_MAX_NUMBER_MASK)
				mml.active_cmd_par_index = mml.execution_based_on_cmd_id_value;
			else {
				mml_send_string("Command index (%d) out of boundaries.\n", mml.execution_based_on_cmd_id_value);
				return 0; 
			}
		}
		
	}
	
	return 1;	
}

void generic_string_parameters(int key_index, int enum_param, char *str_value) {
											
	switch ((enum Emml_commands) mml.active_cmd) {
	__mmlcnf__strpar__;
	__stats__strpar__;
	
	__ss7loc__strpar__;
	__ss7con__strpar__;

	__trnloc__strpar__;
	__trncon__strpar__;

	__m3acon__strpar__;
	__m3loop__strpar__;

	__sccpcf__strpar__;
			
	__bsci__strpar__;
	__btsi__strpar__;
	__mei__strpar__;
	__phonei__strpar__;
	__call__strpar__;
	
	}
									
	if (str_value != NULL) ErrorTraceHandle(2, "<%s> ", str_value);
}




%}

%union {
	char *strVal;
}


%token <strVal> STRING TRACE COMMENTED

%type  <strVal> generalassignment
%type  <strVal> predefinedassignment

%token EQUAL
%token LBRACE RBRACE NEWLINE DOTDOT DOTCOMMA COMMA MINUS

%token tokHELP
%token tokDUMP

%token tokMMLCNF tokSTATS
%token <strVal> tokTRN tokINFO

%token tokSS7LOC tokSS7CON
%token <strVal> tokOWNSP tokSP tokSPTYPE tokNET tokSI tokNI tokSLS

%token tokTRNLOC tokTRNCON
%token <strVal> tokEPID tokSAID tokLIP tokLPN tokMODE tokRIP tokRPN tokUSER

%token tokM3ACON
%token <strVal> tokDEST tokTRNID tokBMODE
%token tokM3LOOP
%token <strVal> tokTRNID1 tokDEST1 tokOWNSP1 tokTRNID2 tokDEST2 tokOWNSP2 tokDIR tokCICINC1 tokCICINC2

%token tokSCCPCF
%token <strVal> tokSSN

%token tokBSCI tokBTSI
%token <strVal> tokBSC tokMSCSP tokCELL tokCGI 

%token tokMEI
%token <strVal> tokME tokIMSI tokRANGE

%token tokPHONEI
%token <strVal> tokPHONE tokANUM tokBNUM tokBDEST

%token tokCALL tokSTART tokSTOP tokDELETE tokPRINT
%token <strVal> tokID tokCALLER tokCALLED tokTYPE tokCPS tokDURATION tokCIC tokCMD


%% 

statements:	
		statements assignments
		| NEWLINE
		| /* NULL */
		;
	
assignments:	
		assignments   generalassignment    COMMA    { ErrorTraceHandle(3, "... ASSGENERAL,\n"); }
		| assignments generalassignment    DOTCOMMA { ErrorTraceHandle(3, "... ASSGENERAL;\n"); }
		| assignments generalassignment    NEWLINE  { ErrorTraceHandle(3, "... ASSGENERAL complete ASS\n"); }
		| assignments predefinedassignment COMMA    { ErrorTraceHandle(3, "... ASSPREDEF,\n"); }
		| assignments predefinedassignment DOTCOMMA { ErrorTraceHandle(3, "... ASSPREDEF;\n"); }
		| assignments predefinedassignment NEWLINE  { ErrorTraceHandle(3, "... ASSPREDEF complete ASS\n"); }
		| TRACE { ErrorTraceHandle(2, "\nACTIVITY: %s\n", $1); }
		| COMMENTED { ErrorTraceHandle(2, "\nCOMMENTED: %s\n", $1); }
		| NEWLINE
		| /* NULL */
		;
		
generalassignment:
	STRING DOTDOT
		{ 
			ErrorTraceHandle(3, "OPENS BRACKETS with <%s> \n", $1); 
		}
		assignments
		{ 
			ErrorTraceHandle(3, "CLOSES BRACKETS "); 
		}
	;

predefinedassignment:

/* *********************************************************************
	MML CMD&PARAM PREDEFINITION
*/

	tokHELP { mml_help(); }
	| tokDUMP { mml_dump(); }

	| tokMMLCNF DOTDOT 
		{ generic_command(0, (enum Emml_commands) mmlcnf, "MMLCNF"); } 
		assignments
		{ if (generic_command(1, (enum Emml_commands) mmlcnf, "MMLCNF")) mml_mmlcnf(); }
	| tokINFO { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) info, $4); }
		
	| tokSTATS DOTDOT 
		{ generic_command(0, (enum Emml_commands) stats, "STATS"); } 
		assignments
		{ if (generic_command(1, (enum Emml_commands) stats, "STATS")) mml_stats(NULL); }
		
	
		
	| tokSS7LOC DOTDOT 
		{ generic_command(0, (enum Emml_commands) ss7loc, "SS7LOC");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) ss7loc, "SS7LOC")) mml_ss7loc();	}
	| tokSS7CON DOTDOT 
		{ generic_command(0, (enum Emml_commands) ss7con, "SS7CON");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) ss7con, "SS7CON")) mml_ss7con();	}
	| tokOWNSP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) ownsp, $6); }
	| tokOWNSP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING MINUS STRING MINUS STRING
		{ char MTPsp[20]; 
		  strcpy(MTPsp, $6);
		  strcat(MTPsp,"-");
		  strcat(MTPsp,$8);
		  strcat(MTPsp,"-");
		  strcat(MTPsp,$10);		  
		  generic_string_parameters(0, (enum Emml_command_parameters) ownsp, MTPsp); }
	| tokSP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) sp, $6); }
	| tokSPTYPE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) sptype, $4); }
	| tokNET { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) net, $4); }
	| tokSI { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) si, $4); }
	| tokNI { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) ni, $4); }
	| tokSLS { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) sls, $4); }
		
		
		
	| tokTRNLOC DOTDOT 
		{ generic_command(0, (enum Emml_commands) trnloc, "TRNLOC");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) trnloc, "TRNLOC"))	mml_trnloc(); }
	| tokTRNCON DOTDOT 
		{ generic_command(0, (enum Emml_commands) trncon, "TRNCON");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) trncon, "TRNCON"))	mml_trncon(); }
	| tokEPID { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) epid, $4); }
	| tokSAID { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) said, $4); }
	| tokLIP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) lip, $4); }
	| tokLPN { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) lpn, $4); }
	| tokRIP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) rip, $4); }
	| tokRPN { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) rpn, $4); }
	| tokMODE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) mode, $4); }
	| tokTRN { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) trn, $4); }
	| tokUSER { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) user, $4); }



	| tokM3ACON DOTDOT 
		{ generic_command(0, (enum Emml_commands) m3acon, "M3ACON");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) m3acon, "M3ACON")) mml_m3acon(); }
	| tokDEST { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) dest, $6); }
	| tokBMODE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) bmode, $4); }
	| tokTRNID { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) trnid, $4); }
	
	
	
	| tokM3LOOP DOTDOT 
		{ generic_command(0, (enum Emml_commands) m3loop, "M3LOOP");  } 
		assignments
		{ if(generic_command(1, (enum Emml_commands) m3loop, "M3LOOP")) mml_m3loop(); }
	| tokOWNSP1 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) ownsp1, $6); }
	| tokTRNID1 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) trnid1, $4); }
	| tokTRNID2 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) trnid2, $4); }
	| tokOWNSP2 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) ownsp2, $6); }
	| tokDEST1 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) dest1, $6); }
	| tokDEST2 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) dest2, $6); }
	| tokDIR { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) dir, $4); }
	| tokCICINC1 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cicinc1, $4); }
	| tokCICINC2 { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cicinc2, $4); }
	
	
	| tokSCCPCF DOTDOT 
		{ generic_command(0, (enum Emml_commands) sccpcf, "SCCPCF");	} 
		assignments
		{ if (generic_command(1, (enum Emml_commands) sccpcf, "SCCPCF")) mml_sccpcf(); }
	| tokSSN { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) ssn, $4); }
	
			
	| tokBSCI DOTDOT 
		{ generic_command(0, (enum Emml_commands) bsci, "BSCI");	} 
		assignments
		{ if(generic_command(1, (enum Emml_commands) bsci, "BSCI")) mml_bsci();	}
	| tokBSC { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) bsc, $4); }
	| tokMSCSP { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) mscsp, $6); }

	| tokBTSI DOTDOT 
		{ generic_command(0, (enum Emml_commands) btsi, "BTSI");	} 
		assignments
		{ if(generic_command(1, (enum Emml_commands) btsi, "BTSI")) mml_btsi(); }
	| tokCELL { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cell, $4); }
	| tokCGI { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING MINUS STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cgi_mcc, $4);
		  generic_string_parameters(0, (enum Emml_command_parameters) cgi_mnc, $6);
		  generic_string_parameters(0, (enum Emml_command_parameters) cgi_lac, $8);
		  generic_string_parameters(0, (enum Emml_command_parameters) cgi_ci, $10); }
			
			
	| tokMEI DOTDOT 
		{ generic_command(0, (enum Emml_commands) mei, "MEI");	} 
		assignments
		{ if(generic_command(1, (enum Emml_commands) mei, "MEI")) mml_mei();	}
	| tokME { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) me, $4); }
	| tokIMSI { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) imsi, $4); }
	| tokRANGE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) range, $4); }


	| tokPHONEI DOTDOT 
		{ generic_command(0, (enum Emml_commands) phonei, "PHONEI");	} 
		assignments
		{ if(generic_command(1, (enum Emml_commands) phonei, "PHONEI")) mml_phonei();	}
	| tokPHONE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) phone, $4); }
	| tokANUM { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) Anum, $4); }
	| tokBNUM { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) Bnum, $4); }
	| tokBDEST { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING MINUS STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) Bdest, $6); }
		
		
	| tokCALL DOTDOT 
		{ generic_command(0, (enum Emml_commands) call, "CALL");	} 
		assignments
		{ if(generic_command(1, (enum Emml_commands) call, "CALL"))	mml_call(); }
	| tokID { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) id, $4); 	}
	| tokCALLER { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) caller, $4); }
	| tokCALLED { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) called, $4); }
	| tokTYPE { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) type, $4); }
	| tokCPS { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cps, $4); }
	| tokDURATION { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) duration, $4); }
	| tokCIC { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ generic_string_parameters(0, (enum Emml_command_parameters) cic, $4); }
				
				
	| tokCMD { ErrorTraceHandle(3, "predef STRING <%s> is recognised and assigned with ", $1); } EQUAL STRING
		{ mml.execution_based_on_cmd_id_value=atoi($4); mml.execution_based_on_cmd_id=true;}
				
	| tokSTART 	{ mml.active_cmd_par_action = (enum Emml_status) start; 	}
	| tokSTOP 	{ mml.active_cmd_par_action = (enum Emml_status) stop; 		}
	| tokDELETE	{ mml.active_cmd_par_action = (enum Emml_status) delete; 	}
	| tokPRINT 	{ mml.active_cmd_par_action = (enum Emml_status) print; 	}
								
	;

/* ********************************************************************* */

%% 
